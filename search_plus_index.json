{"./":{"url":"./","title":"首页","keywords":"","body":"关于本博客 这里是平时心得记录的地方，如果恰好某些心得对n 有帮助，能为你解决掉现实当中的问题，那就再好不过了 如果你觉得非常有用，那么欢迎请我喝咖啡 :) The only way to do great work is to love what you do. If you haven't found it yet, keep looking. Don't settle. As with all matters of the heart, you'll know when you find it. 成就一番伟业的唯一途径就是热爱自己的事业。如果你还没能找到让自己热爱的事业，继续寻找，不要放弃。跟随自己的心，总有一天你会找到的。 Your time is limited, so don't waste it living someone else's life. Don't be trapped by dogma - which is living with the results of other people's thinking. Don't let the noise of other's opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary. 你的时间有限，所以不要为别人而活。不要被教条所限，不要活在别人的观念里。不要让别人的意见左右自己内心的声音。最重要的是，勇敢的去追随自己的心灵和直觉，只有自己的心灵和直觉才知道你自己的真实想法，其他一切都是次要。 If you do something and it turns out pretty good, then you should go do something else wonderful, not dwell on it for too long. Just figure out what’s next。 你如果出色地完成了某件事，那你应该再做一些其他的精彩事儿。不要在前一件事上徘徊太久，想想接下来该做什么。 Being the richest man in the cemetery doesn't matter to me ... Going to bed at night saying we've done something wonderful... that's what matters to me。 是否能成为墓地里最富有的人，对我而言无足轻重。重要的是，当我晚上睡觉时，我可以说：我们今天完成了一些美妙的事。 Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose。 谨记自己总会死去，是让自己避免陷入“人生有所失”思考的最佳方法。 Have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary。 要有勇气追随心声，听从直觉--它们在某种程度上知道你想成为的样子。其他事情都是其次的。 Life is brief, and then you die, you know? 人生短暂，过着过着你就没了，明白嚒？ You can't just ask customers what they want and then try to give that to them. By the time you get it built, they'll want something new。 你不能只问顾客要什么，然后想法子给他们做什么。等你做出来，他们已经另有新欢了。 ♥ Do have faith in what you're doing. Copyright © TsingPost.com 2020 all right reserved，该文件修订时间： 2020-04-15 18:55:05 "},"content/devops/docker.html":{"url":"content/devops/docker.html","title":"docker","keywords":"","body":" 概念 Host（Docker 宿主机） Docker daemon(守护进程)： Images（镜像）： Containers（容器）： Docker Client(客户端) Registry(仓库服务注册器) 基础应用 docker 查看本机容器 docker 查看本机镜像 docker save : 将指定镜像保存成 tar 归档文件。 docker 导入已保存压缩tar镜像 docker 创建容器但不启动它 docker tag 修改 docker 使多端口开放 常用操作 镜像操作 容器操作 创建镜像 更新镜像 使用Dockerfile构建镜像 使用Dockerfile构建Spring Boot应用镜像 扩展阅读 Docker启动就退出的解决方案 概念 Host（Docker 宿主机） 安装了Docker程序，并运行了Docker daemon的主机。 Docker daemon(守护进程)： 运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令)与Docker daemon交互。 Images（镜像）： 将软件环境打包好的模板，用来创建容器的，一个镜像可以创建多个容器。 Containers（容器）： Docker的运行组件，启动一个镜像就是一个容器，容器与容器之间相互隔离，并且互不影响。 Docker Client(客户端) Docker命令行工具，用户是用Docker Clients与Docker daemon进行通信并返回结果给用户。也可以使用其他工具通过Docker Api与Docker daemon通信。 Registry(仓库服务注册器) 经常会和仓库(Repository)混为一谈，实际上Registry上可以有多个仓库，每个仓库可以看成是一个用户， 一个用户的仓库放了多个镜像。仓库分为了公开仓库(Public Repository)和私有仓库(Private Repository)，最大的公开仓库是官方的Docker Hub，国内也有如阿里云、时速云等，可以给国内用户提供稳定快速的服务。用户也可以在本地网络内创建一个私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上pull下来就可以了。 基础应用 docker 查看本机容器 docker ps -a docker 查看本机镜像 docker images docker save : 将指定镜像保存成 tar 归档文件。 docker save -o 目标文件名.tar 镜像名或者id docker 导入已保存压缩tar镜像 docker load -i imagesample.tar docker 创建容器但不启动它 docker create --name myimgname nginx:latest docker tag 修改 可以使用命令: docker tag [image id] [name]:[版本] 例如: docker tag b03b74b01d97 docker-redis:0.0.1 docker 使多端口开放 docker run -it -p20180:80 -p20181:8080 -p20182:8976 --name containerName image:tag 附提交 docker commit -a ‘songlk’ -m ‘commitdesc’ container_nginx centos:7.2.1511 常用操作 输入docker可以查看Docker的命令用法，输入docker COMMAND --help查看指定命令详细用法。 镜像操作 查找镜像： # 搜索docker hub网站镜像的详细信息 docker search 关键词 下载镜像： # Tag表示版本，有些镜像的版本显示latest，为最新版本 docker pull 镜像名:TAG 查看镜像： # 查看本地所有镜像 docker images 删除镜像： # 删除指定本地镜像 docker rmi -f 镜像ID或者镜像名:TAG # -f 表示强制删除 获取元信息： # 获取镜像的元信息，详细信息 docker inspect 镜像ID或者镜像名:TAG 容器操作 运行： docker run --name 容器名 -i -t -p 主机端口:容器端口 -d -v 主机目录:容器目录:ro 镜像TD或镜像名:TAG # --name 指定容器名，可自定义，不指定自动命名 # -i 以交互模式运行容器 # -t 分配一个伪终端，即命令行，通常组合来使用 # -p 指定映射端口，将主机端口映射到容器内的端口 # -d 后台运行容器 # -v 指定挂载主机目录到容器目录，默认为rw读写模式，ro表示只读 windows 示例： docker run --name 起一个容器名 -p 80:80 -p 443:443 -d -v D:\\dkfolder:/usr/share/nginx 容器id 容器列表： # docker ps 查看正在运行的容器 docker ps -a -q # -a 查看所有容器(运行中、未运行) # -q 只查看容器的ID 启动容器： docker start 容器ID或容器名 停止容器： docker stop 容器ID或容器名 删除容器： docker rm -f 容器ID或容器名 # -f 表示强制删除 查看日志： docker logs 容器ID或容器名 进入正在运行容器： docker exec -it 容器ID或者容器名 /bin/bash # 进入正在运行的容器并且开启交互模式终端 # /bin/bash是固有写法，作用是因为docker后台必须运行一个进程，否则容器就会退出，在这里表示启动容器后启动bash。 # 也可以用docker exec在运行中的容器执行命令 拷贝文件： docker cp 主机文件路径 容器ID或容器名:容器路径 # 主机中文件拷贝到容器中 docker cp 容器ID或容器名:容器路径 主机文件路径 # 容器中文件拷贝到主机中 获取容器元信息： docker inspect 容器ID或容器名 创建镜像 有时候从Docker镜像仓库中下载的镜像不能满足要求，我们可以基于一个基础镜像构建一个自己的镜像。 两种方式： 更新镜像：使用docker commit命令 构建镜像：使用docker build命令，需要创建Dockerfile文件 更新镜像 先使用基础镜像创建一个容器，然后对容器内容进行更改，然后使用docker commit命令提交为一个新的镜像（tomcat为例）。 根据基础镜像，创建容器 docker run --name mytomcat -p 80:8080 -d tomcat 修改容器内容 docker exec -it mytomcat /bin/bash cd webapps/ROOT rm -f index.jsp echo hello world > index. html exit 提交为新镜像 docker commit -m=\"描述消息\" -a=\"作者\" 容器ID或容器名 镜像:TAG # 例： # docker commit -m=\"修改了首页\" -a=\"测试\" mytomcat zong/tomcat:v1.0 使用新镜像运行容器 docker run --name tom -p 8080:8080 -d zong/tomcat:v1.0 使用Dockerfile构建镜像 Dockerfile是一个包含创建镜像所有命令的文件，使用docker build命令可以根据Dockerfile的内容创建镜像(以tomcat为例)。 创建一个Dockerfile文件 vi Dockerfile #注意dockerfile指令须大写 FROM tomcat MAINTAINER zong RUN rm -f /usr/local/tomcat/webapps/ROOT/index.jsp RUN echo \"hello world2\" > /usr/local/tomcat/webapps/ROOT/index.html 构建新镜像 docker build -f Dockerfile -t zong/tomcat:v2.0 . # -f Dockerfile路径，默认是当前目录 # -t 指定新镜像的名字以及TAG 使用Dockerfile构建Spring Boot应用镜像 —、准备 把你的spring boot项目打包成可执行jar包 把jar包上传到Linux服务器 二、构建 在jar包路径下创建Dockerfile文件vi Dockerfile # 指定基础镜像，本地没有会从dockerHub pull下来 FROM java:8 # 可执行jar何复制到基础镜像的根目录下 ADD test.jar /test.jar # 镜像要暴露旳端口，如要使用端口，在执行docker run命令时使用-p生效 EXPOSE 8080 # 在镜像运行为容器后执行旳命令 ENTRYPOINT [\"java\", \"-jar\", \"/test.jar\"] 使用docker build命令构建镜像，基本语法 docker build -f Dockerfile -t zong/mypro:v1 . # -f 指定Dockerfile文件的路径 # -t 指定镜像名字和TAG # . 指当前目录，这里实际上需要一个上下文路径 三、运行 运行自己的Spring Boot镜像 docker run --name pro -p 80:80 -d 镜像名:TAG 扩展阅读 Docker启动就退出的解决方案 现象 启动docker容器 docker run –name [CONTAINER_NAME] [CONTAINER_ID] 查看容器运行状态 docker ps -a 发现刚刚启动的mydocker容器已经退出 原因 很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程. 容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的 docker容器的主线程（dockfile中CMD执行的命令）结束，容器会退出 解决方法 可以使用交互式启动 docker run -i [CONTAINER_NAME or CONTAINER_ID] 上面的不太友好，建议使用后台模式和tty选项 docker run -dit [CONTAINER_NAME or CONTAINER_ID] docker调出后台容器 docker attach [CONTAINER_NAME or CONTAINER_ID] TIPs:退出时，使用[ctrl + D]，这样会结束docker当前线程，容器结束，可以使用[ctrl + P][ctrl + Q]退出而不终止容器运行 如下命令，会在指定容器中执行指定命令，[ctrl+D]退出后不会终止容器运行 docker exec -it [CONTAINER_NAME or CONTAINER_ID] /bin/bash 其他方式 将要运行的程序以前台进程的形式运行，如果容器需要同时启动多个进程，那么也只需要将其中一个挂起到前台即可。 比如上面所说的 web 容器，只需要将启动指令修改为: service php5-fpm start && nginx -g \"daemon off;\" 投机方案 对于可能不知道怎么前台运行的程序，提供一个投机方案，只需要在启动的命令之后，添加类似于 tail top 这种可以前台运行的程序，这里推荐tail ，然后持续输出log文件即可。 service nginx start && service php5-fpm start && tail -f /var/log/nginx/error.log 再以上面所说的 web 容器为例，可以写成： service nginx start && service php5-fpm start && tail -f /var/log/nginx/error.log 以centos/ubuntu为例 同上，在启动centos/ubuntu容器时，可以做一个手脚：做一个死循环，持续输出任意，这样容器不会认为没事可做而自杀了。 docker run -d centos /bin/sh -c \"while true; do echo hello world; sleep 1; done\" Copyright © TsingPost.com 2020 all right reserved，该文件修订时间： 2020-04-14 18:35:00 "},"content/devops/nginx.html":{"url":"content/devops/nginx.html","title":"Nginx","keywords":"","body":" 绑定子域名到不同目录（子站） nginx反向代理golang 例如 扩展阅读 nginx location指令详解 root 、alias指令区别 nginx 常见正则符号表示 nginx中 $1,$2,$3是什么? nginx 知识点汇总 一．正则表达式匹配，其中： 二．文件及目录匹配，其中： 三．rewrite指令的最后一项参数为flag标记，flag标记有： 四．NginxRewrite 规则相关指令 五．Nginx的Rewrite规则编写实例 六．nginx全局变量 七．Apache和Nginx规则的对应关系 nginx泛域名解析，实现多个二级域名 利用nginx泛域名解析配置二级域名和多域名，实现二级域名子站，用户个性独立子域名。 主要针对用户独立子域名这种情况，不可能在配置里面将用户子域名写完，因此需要通过nginx泛解析方式。 配置方法： server_name ~^(?.+)\\.yourdomain\\.com$; 通过匹配subdomain即可。而在下面的可以通过$subdomain这个变量获取当前子域名称。 绑定子域名到不同目录（子站） 网站的目录结构为 html ├── bbs └── www html为nginx的安装目录下默认的存放源代码的路径。 bbs为论坛程序源代码路径 www为主页程序源代码路径 把相应程序放入上面的路径通过 http://www.youdomain.com 访问的就是主页 http://bbs.yourdomain.com 访问的就是论坛 其它二级域名类推。 配置实例： server { listen 80; server_name ~^(?.+)\\.yourdomain\\.com$; root html/$subdomain; index index.html index.htm index.php; fastcgi_intercept_errors on; error_page 404 = /404.html; location / { # This is cool because no php is touched for static content. # include the \"?$args\" part so non-default permalinks doesn't # break when using query string try_files $uri $uri/ =404; } # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param domain $subdomain; include fastcgi_params; } # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # location ~ /\\.ht { deny all; } } nginx反向代理golang 简单版本： location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; proxy_pass http://localhost:8080; } 一般静态文件由 nginx 提供，所以可以这样写 root /home/demo/goproj/src/Test/public; try_files $uri/index.html $uri.html $uri @goapp; location @goapp { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; proxy_pass http://localhost:8080; } 例如 现有两个Golang Web服务程序： web1(8080), web2(8081)， 两个域名：www.xxxxx.com， www.yyyy.com 在一台机器上，使xxxxx.com 解析到 8080端口，yyyy.com解析到8081端口 使用nginx进行反向代理的方法： 在nginx配置文件中，添加如下配置 server{ listen 80; server_name www.xxxxx.com xxxxx.com; location /{ try_files /_not_exists @backend; } location @backend{ proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_pass http://localhost:8080; } } 这样域名xxxxx.com,www.xxxxx.com即可解析到服务器 8080端口 server{ listen 80; server_name www.yyyy.com yyyy.com; location /{ try_files /_not_exists @backend; } location @backend{ proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_pass http://localhost:8081; } } 这样域名yyyy.com,www.yyyy.com即可解析到服务器 8081端口。 扩展阅读 nginx location指令详解 Nginx的HTTP配置主要包括三个区块，结构如下： http { //这个是协议级别 　　include mime.types; 　　default_type application/octet-stream; 　　keepalive_timeout 65; 　　gzip on; 　　　　server { //这个是服务器级别 　　　　　　listen 80; 　　　　　　server_name localhost; 　　　　　　　　location / { //这个是请求级别 　　　　　　　　　　root html; 　　　　　　　　　　index index.html index.htm; 　　　　　　　　} 　　　　　　} } location区段 通过指定模式来与客户端请求的URI相匹配，基本语法如下：location [=|~|~*|^~|@] pattern{……} 1、没有修饰符 表示：必须以指定模式开始，如： server { 　　server_name baidu.com; 　　location /abc { 　　　　…… 　　} } 那么，如下是对的： http://baidu.com/abc http://baidu.com/abc?p1 http://baidu.com/abc/ http://baidu.com/abcde 2、=表示：必须与指定的模式精确匹配 server { server_name sish 　　location = /abc { 　　　　…… 　　} } 那么，如下是对的： http://baidu.com/abc http://baidu.com/abc?p1 如下是错的： http://baidu.com/abc/ http://baidu.com/abcde 3、~ 表示：指定的正则表达式要区分大小写 server { server_name baidu.com; 　　location ~ ^/abc$ { 　　　　…… 　　} } 那么，如下是对的： http://baidu.com/abc http://baidu.com/abc?p1=11&p2=22 如下是错的： http://baidu.com/ABC http://baidu.com/abc/ http://baidu.com/abcde 4、~* 表示：指定的正则表达式不区分大小写 server { server_name baidu.com; location ~* ^/abc$ { 　　　　…… 　　} } 那么，如下是对的： http://baidu.com/abc http://baidu..com/ABC http://baidu..com/abc?p1=11&p2=22 如下是错的： http://baidu..com/abc/ http://baidu..com/abcde 5、^~ 类似于无修饰符的行为，也是以指定模式开始，不同的是，如果模式匹配， 那么就停止搜索其他模式了。 6、@ ：定义命名location区段，这些区段客户段不能访问，只可以由内部产生的请 求来访问，如try_files或error_page等 查找顺序和优先级 1：带有“=“的精确匹配优先 2：没有修饰符的精确匹配 3：正则表达式按照他们在配置文件中定义的顺序 4：带有“^~”修饰符的，开头匹配 5：带有“~” 或“~*” 修饰符的，如果正则表达式与URI匹配 6：没有修饰符的，如果指定字符串与URI开头匹配 Location区段匹配示例 location = / { 　　# 只匹配 / 的查询. 　　[ configuration A ] } location / { 　　# 匹配任何以 / 开始的查询，但是正则表达式与一些较长的字符串将被首先匹配。 　　[ configuration B ] } location ^~ /images/ { 　　# 匹配任何以 /images/ 开始的查询并且停止搜索，不检查正则表达式。 　　[ configuration C ] } location ~* \\.(gif|jpg|jpeg)$ { 　　# 匹配任何以gif, jpg, or jpeg结尾的文件，但是所有 /images/ 目录的请求将在Configuration C中处 　　理。 　　[ configuration D ] } 各 请求的处理如下例： ■/ → configuration A ■/documents/document.html → configuration B ■/images/1.gif → configuration C ■/documents/1.jpg → configuration D root 、alias指令区别 location /img/ { alias /var/www/image/; } #若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件 location /img/ { root /var/www/image; } #若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件。 alias是一个目录别名的定义，root则是最上层目录的定义。 还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的。。。而root则可有可无~~ nginx 常见正则符号表示 1、^： 匹配字符串的开始位置； 2、 $：匹配字符串的结束位置； 3、.*: .匹配任意字符，*匹配数量0到正无穷； 4、\\. 斜杠用来转义，\\.匹配 . 特殊使用方法，记住记性了； 5、（值1|值2|值3|值4）：或匹配模式，例：（jpg|gif|png|bmp）匹配jpg或gif或png或bmp 6、i不区分大小写 nginx中 $1,$2,$3是什么? Nginx中，set $para $1，$1表示路径中正则表达式匹配的第一个参数。 以下是一个示例，用以实验$1,$2。如： location ~/abc/(.*)/(.*) { set $para1 $1 set $para2 $2 content_by_lua_block { ngx.say(ngx.var.para1) ngx.say(ngx.var.para2) } } 此时，若访问路径为localhost:8080/abc/qwe/asd时，则浏览器会输出 qwe asd nginx 知识点汇总 一．正则表达式匹配，其中： * ~ 为区分大小写匹配 * ~* 为不区分大小写匹配 * !~和!~*分别为区分大小写不匹配及不区分大小写不匹配 二．文件及目录匹配，其中： * -f和!-f用来判断是否存在文件 * -d和!-d用来判断是否存在目录 * -e和!-e用来判断是否存在文件或目录 * -x和!-x用来判断文件是否可执行 三．rewrite指令的最后一项参数为flag标记，flag标记有： 1.last 相当于apache里面的[L]标记，表示rewrite。 2.break本条规则匹配完成后，终止匹配，不再匹配后面的规则。 3.redirect 返回302临时重定向，浏览器地址会显示跳转后的URL地址。 4.permanent 返回301永久重定向，浏览器地址会显示跳转后的URL地址。 使用last和break实现URI重写，浏览器地址栏不变。而且两者有细微差别，使用alias指令必须用last标记;使用proxy_pass指令时，需要使用break标记。Last标记在本条rewrite规则执行完毕后，会对其所在server{......}标签重新发起请求，而break标记则在本条规则匹配完成后，终止匹配。 例如：如果我们将类似URL/photo/123456 重定向到/path/to/photo/12/1234/123456.png rewrite \"/photo/([0-9]{2})([0-9]{2})([0-9]{2})\"/path/to/photo/$1/$1$2/$1$2$3.png ; 四．NginxRewrite 规则相关指令 1.break指令 使用环境：server,location,if; 该指令的作用是完成当前的规则集，不再处理rewrite指令。 2.if指令 使用环境：server,location 该指令用于检查一个条件是否符合，如果条件符合，则执行大括号内的语句。If指令不支持嵌套，不支持多个条件&&和||处理。 3.return指令 语法：returncode ; 使用环境：server,location,if; 该指令用于结束规则的执行并返回状态码给客户端。 示例：如果访问的URL以\".sh\"或\".bash\"结尾，则返回403状态码 location ~ .*\\.(sh|bash)?$ { return 403; } 4.rewrite 指令 语法：rewriteregex replacement flag 使用环境：server,location,if 该指令根据表达式来重定向URI，或者修改字符串。指令根据配置文件中的顺序来执行。注意重写表达式只对相对路径有效。如果你想配对主机名，你应该使用if语句，示例如下： if( $host ~* www\\.(.*) ) { set $host_without_www $1; rewrite ^(.*)$ http://$host_without_www$1permanent; } 5.Set指令 语法：setvariable value ; 默认值:none; 使用环境：server,location,if; 该指令用于定义一个变量，并给变量赋值。变量的值可以为文本、变量以及文本变量的联合。 示例：set$varname \"hello world\"; 6.Uninitialized_variable_warn指令 语法：uninitialized_variable_warnon|off 使用环境：http,server,location,if 该指令用于开启和关闭未初始化变量的警告信息，默认值为开启。 五．Nginx的Rewrite规则编写实例 1.当访问的文件和目录不存在时，重定向到某个php文件 if( !-e $request_filename ) { rewrite ^/(.*)$ index.php last; } 2.目录对换 /123456/xxxx ====> /xxxx?id=123456 rewrite ^/(\\d+)/(.+)/ /$2?id=$1 last; 3.如果客户端使用的是IE浏览器，则重定向到/ie目录下 if( $http_user_agent ~ MSIE) { rewrite ^(.*)$ /ie/$1 break; } 4.禁止访问多个目录 location ~ ^/(cron|templates)/ { deny all; break; } 5.禁止访问以/data开头的文件 location ~ ^/data { deny all; } 6.禁止访问以.sh,.flv,.mp3为文件后缀名的文件 location ~ .*\\.(sh|flv|mp3)$ { return 403; } 7.设置某些类型文件的浏览器缓存时间 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 30d; } location ~ .*\\.(js|css)$ { expires 1h; } 8.给favicon.ico和robots.txt设置过期时间; 这里为favicon.ico为99天,robots.txt为7天并不记录404错误日志 location ~(favicon.ico) { log_not_found off; expires 99d; break; } location ~(robots.txt) { log_not_found off; expires 7d; break; } 9.设定某个文件的过期时间;这里为600秒，并不记录访问日志 location ^~ /html/scripts/loadhead_1.js { access_log off; root /opt/lampp/htdocs/web; expires 600; break; } 10.文件反盗链并设置过期时间 这里的return412 为自定义的http状态码，默认为403，方便找出正确的盗链的请求 “rewrite ^/ http://img.linuxidc.net/leech.gif;”显示一张防盗链图片 “access_log off;”不记录访问日志，减轻压力 “expires 3d”所有文件3天的浏览器缓存 location ~*^.+\\.(jpg|jpeg|gif|png|swf|rar|zip|css|js)$ { valid_referers none blocked *.linuxidc.com*.linuxidc.net localhost 208.97.167.194; if ($invalid_referer) { rewrite ^/ http://img.linuxidc.net/leech.gif; return 412; break; } access_log off; root /opt/lampp/htdocs/web; expires 3d; break; } 11.只允许固定ip访问网站，并加上密码 root /opt/htdocs/www; allow 208.97.167.194; allow 222.33.1.2; allow 231.152.49.4; deny all; auth_basic “C1G_ADMIN”; auth_basic_user_file htpasswd; 12将多级目录下的文件转成一个文件，增强seo效果 /job-123-456-789.html 指向/job/123/456/789.html rewrite^/job-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ /job/$1/$2/jobshow_$3.html last; 13.文件和目录不存在的时候重定向： if (!-e $request_filename) { proxy_pass http://127.0.0.1; } 14.将根目录下某个文件夹指向2级目录 如/shanghaijob/ 指向 /area/shanghai/ 如果你将last改成permanent，那么浏览器地址栏显是/location/shanghai/ rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last; 上面例子有个问题是访问/shanghai时将不会匹配 rewrite ^/([0-9a-z]+)job$ /area/$1/ last; rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last; 这样/shanghai 也可以访问了，但页面中的相对链接无法使用， 如./list_1.html真实地址是/area/shanghia/list_1.html会变成/list_1.html,导至无法访问。 那我加上自动跳转也是不行咯 (-d $request_filename)它有个条件是必需为真实目录，而我的rewrite不是的，所以没有效果 if (-d $request_filename){ rewrite ^/(.*)([^/])$ http://$host/$1$2/permanent; } 知道原因后就好办了，让我手动跳转吧 rewrite ^/([0-9a-z]+)job$ /$1job/permanent; rewrite ^/([0-9a-z]+)job/(.*)$ /area/$1/$2last; 15.域名跳转 server { listen 80; server_name jump.linuxidc.com; index index.html index.htm index.php; root /opt/lampp/htdocs/www; rewrite ^/ http://www.linuxidc.com/; access_log off; } 16.多域名转向 server_name www.linuxidc.comwww.linuxidc.net; index index.html index.htm index.php; root /opt/lampp/htdocs; if ($host ~ \"linuxidc\\.net\") { rewrite ^(.*) http://www.linuxidc.com$1permanent; } 六．nginx全局变量 arg_PARAMETER #这个变量包含GET请求中，如果有变量PARAMETER时的值。 args #这个变量等于请求行中(GET请求)的参数，如：foo=123&bar=blahblah; binary_remote_addr #二进制的客户地址。 body_bytes_sent #响应时送出的body字节数数量。即使连接中断，这个数据也是精确的。 content_length #请求头中的Content-length字段。 content_type #请求头中的Content-Type字段。 cookie_COOKIE #cookie COOKIE变量的值 document_root #当前请求在root指令中指定的值。 document_uri #与uri相同。 host #请求主机头字段，否则为服务器名称。 hostname #Set to themachine’s hostname as returned by gethostname http_HEADER is_args #如果有args参数，这个变量等于”?”，否则等于”\"，空值。 http_user_agent #客户端agent信息 http_cookie #客户端cookie信息 limit_rate #这个变量可以限制连接速率。 query_string #与args相同。 request_body_file #客户端请求主体信息的临时文件名。 request_method #客户端请求的动作，通常为GET或POST。 remote_addr #客户端的IP地址。 remote_port #客户端的端口。 remote_user #已经经过Auth Basic Module验证的用户名。 request_completion #如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)。 request_method #GET或POST request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。 request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。 scheme #HTTP方法（如http，https）。 server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 server_addr #服务器地址，在完成一次系统调用后可以确定这个值。 server_name #服务器名称。 server_port #请求到达服务器的端口号。 七．Apache和Nginx规则的对应关系 Apache的RewriteCond对应Nginx的if Apache的RewriteRule对应Nginx的rewrite Apache的[R]对应Nginx的redirect Apache的[P]对应Nginx的last Apache的[R,L]对应Nginx的redirect Apache的[P,L]对应Nginx的last Apache的[PT,L]对应Nginx的last 例如：允许指定的域名访问本站，其他的域名一律转向www.linuxidc.net Apache: RewriteCond %{HTTP_HOST} !^(.*?)\\.aaa\\.com$[NC] RewriteCond %{HTTP_HOST} !^localhost$ RewriteCond %{HTTP_HOST}!^192\\.168\\.0\\.(.*?)$ RewriteRule ^/(.*)$ http://www.linuxidc.net[R,L] Nginx: if( $host ~* ^(.*)\\.aaa\\.com$ ) { set $allowHost ‘1’; } if( $host ~* ^localhost ) { set $allowHost ‘1’; } if( $host ~* ^192\\.168\\.1\\.(.*?)$ ) { set $allowHost ‘1’; } if( $allowHost !~ ‘1’ ) { rewrite ^/(.*)$ http://www.linuxidc.netredirect ; } Copyright © TsingPost.com 2020 all right reserved，该文件修订时间： 2020-04-14 14:29:18 "},"content/devops/letsencrypt.html":{"url":"content/devops/letsencrypt.html","title":"ssl证书","keywords":"","body":" 执行 执行命令 解决问题 输出 证书续签 证书保存的路径[配置nginx需要用到的] 取消证书 扩展阅读 如何申请 Let’s Encrypt 通配符证书 实践 安装 git clone https://github.com/letsencrypt/letsencrypt 执行 cd letsencrypt ./certbot-auto certonly -d *.你的域名 --manual --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory 这里用了泛域名证书 执行命令 如果上面报错 OSError: Command /opt/eff.org/certbot/venv/bin/python2.7 - setuptools pip wheel failed with error code 1 解决问题 卸载virtualenv： pip uninstall virtualenv 再安装virtualenv ： pip install virtualenv==15.1.0 输出 ackage gcc-4.8.5-36.el7_6.2.x86_64 already installed and latest version Package augeas-libs-1.4.0-6.el7_6.1.x86_64 already installed and latest version Package 1:openssl-1.0.2k-16.el7_6.1.x86_64 already installed and latest version Package 1:openssl-devel-1.0.2k-16.el7_6.1.x86_64 already installed and latest version Package libffi-devel-3.0.13-18.el7.x86_64 already installed and latest version Package redhat-rpm-config-9.1.0-87.el7.centos.noarch already installed and latest version Package ca-certificates-2018.2.22-70.0.el7_5.noarch already installed and latest version Package python-devel-2.7.5-77.el7_6.x86_64 already installed and latest version Package python-virtualenv-15.1.0-2.el7.noarch already installed and latest version Package python-tools-2.7.5-77.el7_6.x86_64 already installed and latest version Package python2-pip-8.1.2-8.el7.noarch already installed and latest version Nothing to do Creating virtual environment... Installing Python packages... Installation succeeded. Saving debug log to /var/log/letsencrypt/letsencrypt.log Plugins selected: Authenticator manual, Installer None Enter email address (used for urgent renewal and security notices) (Enter 'c' to cancel): 531833XXX@qq.com Please read the Terms of Service at https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must agree in order to register with the ACME server at https://acme-v02.api.letsencrypt.org/directory 是否通用协议，选择是，那就是'A' A Would you be willing to share your email address with the Electronic Frontier Foundation, a founding partner of the Let's Encrypt project and the non-profit organization that develops Certbot? We'd like to send you email about our work encrypting the web, EFF news, campaigns, and ways to support digital freedom. 是否分享你的邮箱，否 N NOTE: The IP of this machine will be publicly logged as having requested this certificate. If you're running certbot in manual mode on a machine that is not your server, please ensure you're okay with that. 询问是否对域名和机器（IP）进行绑定=>需要同意 Y 需要按照要求(指定key：value)在dns设置一条txt记录，在dns设置完成之前不能回车 Please deploy a DNS TXT record under the name _acme-challenge.ippnetwork.com with the following value: sFT0ouhU4sktQl8_D8XPySBKUnLfmoGe_Ief4Kr7P1I Before continuing, verify the record is deployed. 此处key设置注意，去掉域名后缀，按上方例子，key值为_acme-challenge 回车后将会验证，成功后提示如下： Press Enter to Continue Waiting for verification... Cleaning up challenges IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/ippnetwork.com/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/ippnetwork.com/privkey.pem Your cert will expire on 2020-03-02. To obtain a new or tweaked version of this certificate in the future, simply run certbot-auto again. To non-interactively renew *all* of your certificates, run \"certbot-auto renew\" - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 证书续签 注:证书在到期前30天才会续签成功,但为了确保证书在运行过程中不过期,官方建议每天自动执行续签两次; 使用crontab自动续期 crontab -e // 编辑定时任务 0 */12 * * * certbot renew --quiet --renew-hook \"/etc/init.d/nginx reload\" 证书保存的路径[配置nginx需要用到的] /etc/letsencrypt/live/you.cn/fullchain.pem /etc/letsencrypt/live/you.cn/privkey.pem nginx配置样例： server { listen 80; server_name ippnetwork.com; root /usr/share/nginx/www; } server { listen *:443 ssl http2; root /usr/share/nginx/www; server_name ippnetwork.com; ssl_certificate /etc/letsencrypt/live/ippnetwork.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/ippnetwork.com/privkey.pem; } 取消证书 可以使用一下命令取消刚刚生成的密匙，也就是以上的反操作： certbot revoke --cert-path /etc/letsencrypt/live/you.cn/cert.pem certbot delete --cert-name you.cn 扩展阅读 如何申请 Let’s Encrypt 通配符证书 为了实现通配符证书，Let’s Encrypt 对 ACME 协议的实现进行了升级，只有 v2 协议才能支持通配符证书。 也就是说任何客户端只要支持 ACME v2 版本，就可以申请通配符证书了，是不是很激动。 读者可以查看下自己惯用的客户端是不是支持 ACME v2 版本，官方介绍 Certbot 0.22.0 版本支持新的协议版本，我立刻进行了升级： ./certbot-auto -V Upgrading certbot-auto 0.21.1 to 0.22.0... Replacing certbot-auto... ./certbot-auto -V certbot 0.22.0 在了解该协议之前有几个注意点： 1）客户在申请 Let’s Encrypt 证书的时候，需要校验域名的所有权，证明操作者有权利为该域名申请证书，目前支持三种验证方式： dns-01：给域名添加一个 DNS TXT 记录。 http-01：在域名对应的 Web 服务器下放置一个 HTTP well-known URL 资源文件。 tls-sni-01：在域名对应的 Web 服务器下放置一个 HTTPS well-known URL 资源文件。 而申请通配符证书，只能使用 dns-01 的方式 2）ACME v2 和 v1 协议是互相不兼容的，为了使用 v2 版本，客户端需要创建另外一个账户（代表客户端操作者），以 Certbot 客户端为例，大家可以查看： $ tree /etc/letsencrypt/accounts . ├── acme-staging.api.letsencrypt.org ├── acme-v01.api.letsencrypt.org └── acme-v02.api.letsencrypt.org 3）Enumerable Orders 和限制 为了实现通配符证书，Let's Encrypt 在申请者身份校验上做了很大的改变。 有了订单 ID 的概念，主要是为了追踪通配符域名。 申请限制，在 V1 版本，Let's Encrypt 为了避免滥操作，对申请证书有一些限制（很难学习，但是正常使用不会遇到该限制）。而 v2 版本，对于通配符证书，多了一个限制，New Orders per Account（每个证书订单数限制）。 这两个细节，后续再仔细研究。 实践 我迫不及待想使用 Certbot 申请通配符证书，升级 Certbot 版本运行下列命令： ./certbot-auto certonly -d *.newyingyong.cn --manual --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory 介绍下相关参数： certonly，表示安装模式，Certbot 有安装模式和验证模式两种类型的插件。 --manual 表示手动安装插件，Certbot 有很多插件，不同的插件都可以申请证书，用户可以根据需要自行选择 -d 为那些主机申请证书，如果是通配符，输入 *.newyingyong.cn（可以替换为你自己的域名） --preferred-challenges dns，使用 DNS 方式校验域名所有权 --server，Let's Encrypt ACME v2 版本使用的服务器不同于 v1 版本，需要显示指定。 接下去就是命令行的输出： Saving debug log to /var/log/letsencrypt/letsencrypt.log Plugins selected: Authenticator manual, Installer None Enter email address (used for urgent renewal and security notices) (Enter 'c' to cancel): ywdblog@gmail.com ------------------------------------------------------------------------------- Please read the Terms of Service at https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must agree in order to register with the ACME server at https://acme-v02.api.letsencrypt.org/directory ------------------------------------------------------------------------------- (A)gree/(C)ancel: A Plugins selected: Authenticator manual, Installer None Obtaining a new certificate Performing the following challenges: dns-01 challenge for newyingyong.cn ------------------------------------------------------------------------------- NOTE: The IP of this machine will be publicly logged as having requested this certificate. If you're running certbot in manual mode on a machine that is not your server, please ensure you're okay with that. Are you OK with your IP being logged? ------------------------------------------------------------------------------- (Y)es/(N)o: y 上述有两个交互式的提示： 是否同意 Let's Encrypt 协议要求 询问是否对域名和机器（IP）进行绑定 确认同意才能继续。 继续查看命令行的输出，非常关键： ------------------------------------------------------------------------------- Please deploy a DNS TXT record under the name _acme-challenge.newyingyong.cn with the following value: 2_8KBE_jXH8nYZ2unEViIbW52LhIqxkg6i9mcwsRvhQ Before continuing, verify the record is deployed. ------------------------------------------------------------------------------- Press Enter to Continue Waiting for verification... Cleaning up challenges 要求配置 DNS TXT 记录，从而校验域名所有权，也就是判断证书申请者是否有域名的所有权。 上面输出要求给 _acme-challenge.newyingyong.cn 配置一条 TXT 记录，在没有确认 TXT 记录生效之前不要回车执行。 我使用的是阿里云的域名服务器，登录控制台操作如下图： https.png 然后输入下列命令确认 TXT 记录是否生效： $ dig -t txt _acme-challenge.newyingyong.cn @8.8.8.8 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;_acme-challenge.newyingyong.cn. IN TXT ;; ANSWER SECTION: _acme-challenge.newyingyong.cn. 599 IN TXT \"2_8KBE_jXH8nYZ2unEViIbW52LhIqxkg6i9mcwsRvhQ\" 确认生效后，回车执行，输出如下： IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/newyingyong.cn/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/newyingyong.cn/privkey.pem Your cert will expire on 2018-06-12. To obtain a new or tweaked version of this certificate in the future, simply run certbot-auto again. To non-interactively renew *all* of your certificates, run \"certbot-auto renew\" - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 恭喜您，证书申请成功，证书和密钥保存在下列目录： $ tree /etc/letsencrypt/archive/newyingyong.cn . ├── cert1.pem ├── chain1.pem ├── fullchain1.pem └── privkey1.pem 然后校验证书信息，输入如下命令： openssl x509 -in /etc/letsencrypt/archive/newyingyong.cn/cert1.pem -noout -text 关键输出如下： X509v3 Subject Alternative Name: DNS:*.newyingyong.cn Copyright © TsingPost.com 2020 all right reserved，该文件修订时间： 2019-12-03 18:42:02 "}}